pub mod data_availability;
pub mod db;
pub mod errors;
pub mod macros;
pub mod piltover;
pub mod prover;
pub mod starknet;
pub mod utlis;

use cairo_vm::types::layout_name::LayoutName;
use db::sql_lite::SqliteDb;
use db::{BlockStatus, ProverStatus, SayaProvingDb};
use errors::Error;
use piltover::Piltover;
use prove_block::prove_block;
use starknet::account::StarknetAccountData;
use starknet_types_core::felt::Felt;
use tokio::join;
use tokio::sync::broadcast;
use tracing::{info, trace};
use url::Url;

use crate::prover::atlantic::AtlanticProver;
use crate::utlis::graceful_shutdown::shutdown_signal;
use crate::utlis::pie::CairoPieBytes;

const SNOS: &[u8; 37909480] = include_bytes!("../../../bin/saya/programs/snos.json");

pub struct Saya {
    pub config: SayaConfig,
    pub last_settled_block: u32,
    pub last_sent_for_prove_block: u32,
    pub db: SqliteDb,
    pub piltover: Piltover,
    pub prover: AtlanticProver,
}
#[derive(Debug)]
pub struct SayaConfig {
    pub rpc_url: Url,
    pub prover_url: Url,
    pub prover_key: String,
    pub settlement_contract: Felt,
    pub settlement_rpc_url: Url,
    pub starknet_account: StarknetAccountData,
}

impl Saya {
    pub async fn new(config: SayaConfig) -> Result<Saya, Error> {
        let piltover = Piltover {
            contract: config.settlement_contract,
            account: config.starknet_account.get_starknet_account(),
        };
        let last_settled_block = piltover.get_state().await.block_number;

        let db = SqliteDb::new("blocks.db").await?;
        let blocks = db.list_blocks().await?;
        let last_sent_for_prove_block = blocks
            .iter()
            .max_by_key(|block| block.id)
            .map(|block| block.id)
            .unwrap_or(last_settled_block);
        let prover = AtlanticProver::new(
            config.prover_key.clone(),
            config.prover_url.clone(),
            db.clone(),
        );

        info!("Saya initialized");
        info!("Last settled block: {}", last_settled_block);
        info!("Last sent for prove block: {}", last_sent_for_prove_block);
        Ok(Saya {
            config,
            last_settled_block,
            last_sent_for_prove_block,
            db,
            piltover,
            prover,
        })
    }

    pub async fn start(&mut self) -> Result<(), Error> {
        let (tx, _) = broadcast::channel(1);
        let pie_rx = tx.subscribe();
        let monitor_proof_rx = tx.subscribe();
        let submit_layout_bridge_rx = tx.subscribe();
        let monitor_layout_bridge_rx = tx.subscribe();
        let settle_block_rx = tx.subscribe();

        let (
            submit_pie_result,
            monitor_proof_status_result,
            submit_layout_bridge_result,
            monitor_layout_bridge_result,
            settle_block_result,
            _,
        ) = join!(
            self.submit_pie(pie_rx),
            self.monitor_proof_status(monitor_proof_rx),
            self.submit_layout_bridge(submit_layout_bridge_rx),
            self.monitor_layout_bridge_status(monitor_layout_bridge_rx),
            self.settle_block(settle_block_rx),
            shutdown_signal(tx)
        );
        // Check each result and return the first encountered error
        submit_pie_result?;
        monitor_proof_status_result?;
        submit_layout_bridge_result?;
        monitor_layout_bridge_result?;
        settle_block_result?;
        Ok(())
    }

    /// Calculates the pie for a block and submits it to the prover for proof generation.
    ///
    /// This function continuously generates pies for blocks, checking for blocks with a status
    /// of `ProverStatus::PieSubmitted`. If too many pending blocks exist, it waits before resuming.
    ///
    /// Pie is a provable "trace" of block generated by snos with prove_block function.
    /// # Returns
    /// Returns an `Error` if the pie generation or submission fails.
    async fn submit_pie(&self, mut shutdown_rx: broadcast::Receiver<()>) -> Result<(), Error> {
        let mut block_number = self.last_sent_for_prove_block;
        let blocks = self.db.list_blocks_with_status(BlockStatus::Failed).await?;
        block_number = blocks
            .iter()
            .min_by_key(|block| block.id)
            .map(|block| block.id)
            .unwrap_or(block_number);
        let poll_interval_secs = 10;
        loop {
            tokio::select! {
                _ = shutdown_rx.recv() => {
                    info!("Shutting down submit_pie");
                    break Ok(());
                }
                _ = tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs))=>{
                    if self.db.list_blocks_with_status(BlockStatus::PieSubmitted).await?.len() >= 2 {
                        trace!("Too many pending blocks, waiting");
                    } else {
                        let mut rpc_url = self.config.rpc_url.clone().to_string();
                        if rpc_url.ends_with('/') {
                            rpc_url.pop();
                        }
                        let (pie, _) = prove_block(
                            SNOS,
                            block_number.into(),
                            &rpc_url,
                            LayoutName::all_cairo,
                            true,
                        )
                        .await?;
                        let pie = pie.to_bytes();
                        let label = format!("block_{}", block_number);
                        let query_id = self.prover.submit_proof_generation(pie,&label).await?;
                        info!("Block status updated to PieSubmitted for block {}", block_number);
                        self.db.insert_block(block_number, &query_id, BlockStatus::PieSubmitted).await?;
                        block_number += 1;
                    }
                }
            }
        }
    }

    /// Monitors the proof status of pie proofs submitted to the prover.
    ///
    /// This function periodically checks the status of proof generation for blocks with
    /// `ProverStatus::PieSubmitted` and updates the status when proofs are completed.
    ///
    /// # Returns
    /// Returns an `Error` if there is an issue with status checking or database updates.
    async fn monitor_proof_status(
        &self,
        mut shutdown_rx: broadcast::Receiver<()>,
    ) -> Result<(), Error> {
        let poll_interval_secs = 10;
        loop {
            tokio::select! {
                    _ = shutdown_rx.recv() => {
                        info!("Shutting down monitor_proof_status");
                        break Ok(());
                    }
                    _ = tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs))=>{
                        let pending_blocks =
                        self.db.list_blocks_with_status(BlockStatus::PieSubmitted).await?;
                        for block in pending_blocks {
                            match self.prover.check_query_status(block.id, &block.query_id_step1).await? {
                            ProverStatus::Proved => {
                                let proof = self.prover.fetch_proof(&block.query_id_step1).await?;
                                self.db.insert_pie_proof(block.id, &proof).await?;
                                info!("Block status updated to PieProofGenerated for block {}", block.id);
                            }
                            ProverStatus::Proving => {
                                trace!(
                                    "Some jobs are not completed for block {}, query_id {}",
                                    block.id, block.query_id_step1
                                );
                            }
                            ProverStatus::Failed => {
                                //If job failed, we need to resubmit the proof
                                self.db.update_block_status(block.id, BlockStatus::Failed).await?;
                            }
                        }
                    }
                }
            }
        }
    }

    /// Submits bridge proof requests for blocks with completed pie proofs.
    ///
    /// This function submits a layout bridge request for blocks with the
    /// `ProverStatus::PieProofGenerated` status and updates their status to
    /// `ProverStatus::BridgeProofSubmitted`.
    ///
    /// Layout bridge takes the pie proof generated with dynamic layout and generates a bridge proof
    /// in layout starknet with keccak which is verifiable on Herodotus Integrity.
    ///
    /// # Returns
    /// Returns an `Error` if there is an issue with proof submission or database updates.
    async fn submit_layout_bridge(
        &self,
        mut shutdown_rx: broadcast::Receiver<()>,
    ) -> Result<(), Error> {
        let poll_interval_secs = 10;
        loop {
            tokio::select! {
                _ = shutdown_rx.recv() => {
                    info!("Shutting down submit_layout_bridge");
                    break Ok(());
                }
                _ = tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs))=>{
                    let pie_generated_blocks =
                    self.db.list_blocks_with_status(BlockStatus::PieProofGenerated).await?;
                for block in pie_generated_blocks {
                    let pie_proof = self.db.get_pie_proof(block.id).await?;
                    let label = format!("bridge_{}", block.id);
                    let query_id = self.prover.submit_atlantic_query(pie_proof,&label).await?;
                    self.db.update_block_query_id_for_bridge_proof(block.id, &query_id).await?;
                    info!("Block status updated to BridgeProofSubmited for block {}", block.id);
                    }
                }
            }
        }
    }

    /// Monitors the status of bridge proofs submitted to the prover.
    ///
    /// This function periodically checks the status of bridge proofs and updates the database once
    /// proofs are completed.
    ///
    /// ###+
    ///  Returns
    /// Returns an `Error` if there is an issue with status checking or database updates.
    async fn monitor_layout_bridge_status(
        &self,
        mut shutdown_rx: broadcast::Receiver<()>,
    ) -> Result<(), Error> {
        let poll_interval_secs = 10;
        loop {
            tokio::select! {
                    _ = shutdown_rx.recv() => {
                        info!("Shutting down monitor_layout_bridge_status");
                        break Ok(());
                    }
                    _ = tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs))=>{
                        let blocks = self.db.list_blocks_with_status(BlockStatus::BridgeProofSubmited).await?;
                        for block in blocks {
                            match self.prover.check_query_status(block.id, &block.query_id_step2).await? {
                                ProverStatus::Proved => {
                                    let proof = self.prover.fetch_proof(&block.query_id_step2).await?;
                                    self.db.insert_bridge_proof(block.id, &proof).await?;
                                    info!("Block status updated to Completed for block {}", block.id);
                                }
                                ProverStatus::Proving => {
                                    trace!(
                                        "Some jobs are not completed for block {}, query_id {}",
                                        block.id, block.query_id_step2
                                    );
                                }
                                ProverStatus::Failed => {
                                    //If job failed, we need to resubmit the proof
                                    self.db.update_block_status(block.id, BlockStatus::PieProofGenerated).await?;
                                }
                            }
                        }
                }
            }
        }
    }
    /// Settles completed blocks on the blockchain using pie and bridge proofs as input.
    ///
    /// This function iterates over blocks with `ProverStatus::Completed`, chooses first unsettled
    /// block and uses Piltover to settle that block on-chain.
    ///
    /// # Returns
    /// Returns an `Error` if there is an issue retrieving proofs or updating Piltover state.
    async fn settle_block(&self, mut shutdown_rx: broadcast::Receiver<()>) -> Result<(), Error> {
        let poll_interval_secs = 10;
        let state = self.piltover.get_state().await;
        let last_settled_block = state.block_number;
        let mut block_number = last_settled_block;
        loop {
            tokio::select! {
                _ = shutdown_rx.recv() => {
                    info!("Shutting down settle_block");
                    break Ok(());
                }
                _ = tokio::time::sleep(std::time::Duration::from_secs(poll_interval_secs))=>{
                    let blocks = self.db.list_blocks_with_status(BlockStatus::Completed).await?;
                    let block = blocks.iter().find(|block| block.id == block_number);
                    if block.is_none() {
                        continue;
                    } else {
                        let pie_proof = self.db.get_pie_proof(block_number).await?;
                        let bridge_proof = self.db.get_bridge_proof(block_number).await?;
                        self.piltover.update_state(pie_proof, bridge_proof,block_number).await?;
                        // remove block from db
                        // remove proofs from db
                        block_number += 1;
                    }
                }
            }
        }
    }
}
