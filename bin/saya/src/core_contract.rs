use std::{fs, path::Path};

use anyhow::Result;
use clap::Parser;

use anyhow::anyhow;
use cairo_lang_starknet_classes::casm_contract_class::CasmContractClass;
use cairo_lang_starknet_classes::contract_class::ContractClass;
use dojo_utils::{Declarer, Deployer, Invoker, LabeledClass, TransactionResult, TxnConfig};
use log::trace;
use starknet::accounts::{Account, SingleOwnerAccount};
use starknet::core::crypto::compute_hash_on_elements;
use starknet::core::types::contract::SierraClass;
use starknet::core::types::{Call, Felt, FlattenedSierraClass};
use starknet::macros::{felt, selector};
use starknet::providers::jsonrpc::HttpTransport;
use starknet::providers::{JsonRpcClient, Provider};
use starknet::signers::{LocalWallet, SigningKey};
use starknet_api::contract_class::compiled_class_hash::{HashVersion, HashableCompiledClass};
use url::Url;

pub const SEPOLIA_RPC_URL: &str = "https://api.cartridge.gg/x/starknet/sepolia";
pub const DEFAULT_PILTOVER_PATH: &str = "programs/core_contract.json";

/// The StarknetOS program (SNOS) is the cairo program that executes the state
/// transition of a new Katana block from the previous block.
/// This program hash is required to be known by the settlement contract in order to
/// only accept a new state from a valid SNOS program.
///
/// This program can be found here: <https://github.com/starkware-libs/cairo-lang/blob/a86e92bfde9c171c0856d7b46580c66e004922f3/src/starkware/starknet/core/os/os.cairo>.
const SNOS_PROGRAM_HASH: Felt =
    felt!("0x054d3603ed14fb897d0925c48f26330ea9950bd4ca95746dad4f7f09febffe0d");

/// To execute the SNOS program, a specific layout named "all_cairo" is required.
/// However, this layout can't be verified by the Cairo verifier that lives on Starknet.
///
/// This is why we're using an other program, the Layout Bridge program, which act as a verifier
/// written in Cairo which uses a layout supported by the Cairo verifier.
///
/// By verifying a SNOS proof using the Layout Bridge program, a new proof is generated which can be
/// verified by the Cairo verifier.
///
/// For the same reason as above, the Layout Bridge program is required to be known by the
/// settlement contract for security reasons.
///
/// This program can be found here: <https://github.com/starkware-libs/cairo-lang/blob/8276ac35830148a397e1143389f23253c8b80e93/src/starkware/cairo/cairo_verifier/layouts/all_cairo/cairo_verifier.cairo>.
const LAYOUT_BRIDGE_PROGRAM_HASH: Felt =
    felt!("0x193641eb151b0f41674641089952e60bc3aded26e3cf42793655c562b8c3aa0");

/// The bootloader program hash is the program hash of the bootloader program.
///
/// This program is used to run the layout bridge program in SHARP. This program hash is also
/// required since the fact is computed based on the bootloader program hash and its output.
///
/// TODO: waiting for SHARP team to confirm if it's a custom bootloader or if we
/// can find it in cairo-lang.
const BOOTLOADER_PROGRAM_HASH: Felt =
    felt!("0x5ab580b04e3532b6b18f81cfa654a05e29dd8e2352d88df1e765a84072db07");

const INITIAL_STATE_ROOT: Felt = Felt::ZERO;
/// When updating the piltover contract with the genesis block (ie block number 0), in the
/// attached StarknetOsOutput, the [previous block number] is expected to be
/// `0x800000000000011000000000000000000000000000000000000000000000000`. Which is the
/// maximum value of a [`Felt`].
///
/// It is a value generated by StarknetOs.
///
/// [previous block number]: https://github.com/keep-starknet-strange/piltover/blob/a7d6b17f855f2295a843bfd0ab0dcd696c6229a8/src/snos_output.cairo#L34
const INITIAL_BLOCK_NUMBER: Felt = Felt::MAX;
const INITIAL_BLOCK_HASH: Felt = Felt::ZERO;

const ATLANTIC_FACT_REGISTRY_SEPOLIA: Felt =
    felt!("0x4ce7851f00b6c3289674841fd7a1b96b6fd41ed1edc248faccd672c26371b8c");

const STRK_FEE_TOKEN: Felt =
    felt!("0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d");
#[derive(Debug, Parser)]
pub struct CoreContract {
    /// Private key of the settlement account used to declare the core contract.
    #[clap(long, env = "SETTLEMENT_ACCOUNT_PRIVATE_KEY")]
    private_key: String,
    #[clap(long, env = "ACCOUNT_ADDRESS")]
    account_address: String,
    #[clap(long, env = "CORE_CONTRACT_PATH", default_value = DEFAULT_PILTOVER_PATH)]
    core_contract_path: String,
    #[clap(long, env = "SALT", default_value = "0x5")]
    salt: Felt,
    #[clap(long, env = "FACT_REGISTRY_ADDRESS")]
    fact_registry_address: Option<Felt>,
}

impl CoreContract {
    pub async fn run(self) -> Result<()> {
        let provider = JsonRpcClient::new(HttpTransport::new(Url::parse(SEPOLIA_RPC_URL)?));
        let signer: LocalWallet = LocalWallet::from_signing_key(SigningKey::from_secret_scalar(
            Felt::from_hex(&self.private_key).expect("Invalid private key"),
        ));

        let address = Felt::from_hex(&self.account_address).expect("Invalid address");

        let chain_id = provider.chain_id().await.expect("Failed to fetch chain id");
        let encoding = starknet::accounts::ExecutionEncoding::New;
        let account = starknet::accounts::SingleOwnerAccount::new(
            provider,
            signer.clone(),
            address,
            chain_id,
            encoding,
        );

        let class_hash =
            declare_core_contract(account.clone(), Path::new(&self.core_contract_path)).await?;
        println!("Core contract declared with class hash: {class_hash:#066x}");
        let contract_address = deploy_core_contract(account.clone(), class_hash, self.salt).await?;
        println!("Core contract deployed at address: {contract_address:#066x}");
        let snos_config_hash = compute_starknet_os_config_hash(chain_id,STRK_FEE_TOKEN, STRK_FEE_TOKEN);
        set_program_info(account.clone(), contract_address, snos_config_hash).await?;

        set_fact_registry(
            account.clone(),
            contract_address,
            self.fact_registry_address
                .unwrap_or(ATLANTIC_FACT_REGISTRY_SEPOLIA),
        )
        .await?;
        Ok(())
    }
}

pub async fn declare_core_contract(
    account: SingleOwnerAccount<JsonRpcClient<HttpTransport>, LocalWallet>,
    core_contract_path: &Path,
) -> Result<Felt> {
    let txn_config = TxnConfig::default();

    let mut declarer = Declarer::new(account, txn_config);
    let class = prepare_class(core_contract_path, true)?;
    let labeled = LabeledClass {
        label: class.label.clone(),
        casm_class_hash: class.casm_class_hash,
        class: class.class.clone(),
    };
    declarer.add_class(labeled);
    let results = declarer.declare_all().await?;

    // There is only one class to declare.
    let class_hash = match &results[0] {
        TransactionResult::Noop => {
            println!("Core contract already declared on-chain.");
            class.class_hash
        }
        TransactionResult::Hash(hash) => {
            println!("Core contract declared.");
            println!("  Tx hash   : {hash:#066x}");
            *hash
        }
        TransactionResult::HashReceipt(hash, _receipt) => {
            println!("Core contract declared.");
            println!("  Tx hash   : {hash:#066x}");
            *hash
        }
    };
    return Ok(class_hash);
}

pub async fn deploy_core_contract(
    account: SingleOwnerAccount<JsonRpcClient<HttpTransport>, LocalWallet>,
    class_hash: Felt,
    salt: Felt,
) -> Result<Felt> {
    let txn_config = TxnConfig::default();

    let deployer = Deployer::new(account.clone(), txn_config);
    let constructor_calldata: Vec<Felt> = vec![
        // owner.
        account.address(),
        // state root.
        INITIAL_STATE_ROOT,
        // block_number must be magic value for genesis block.
        INITIAL_BLOCK_NUMBER,
        // block_hash.
        INITIAL_BLOCK_HASH,
    ];

    match deployer
        .deploy_via_udc(class_hash, salt, &constructor_calldata, account.address())
        .await
    {
        Ok((contract_address, transaction_result)) => {
            println!("Core contract deployed.");
            trace!(
                "{} {}",
                format!("{:#066x}", contract_address),
                format!("{:?}", transaction_result),
            );
            Ok(contract_address)
        }
        Err(e) => {
            // Try to extract address from "already deployed" error
            let error_msg = format!("{:?}", e);
            if error_msg.contains("already deployed at address") {
                // Extract address from error message
                if let Some(start) = error_msg.find("already deployed at address 0x") {
                    let addr_start = start + "already deployed at address ".len();
                    if let Some(end) =
                        error_msg[addr_start..].find(|c: char| !c.is_ascii_hexdigit() && c != 'x')
                    {
                        let addr_str = &error_msg[addr_start..addr_start + end];
                        if let Ok(address) = Felt::from_hex(addr_str) {
                            println!(
                                "Core contract already deployed at address: {:#066x}",
                                address
                            );
                            return Ok(address);
                        }
                    }
                }
            }
            Err(anyhow!("Deployment failed: {:?}", e))
        }
    }
}

pub async fn set_program_info(
    account: SingleOwnerAccount<JsonRpcClient<HttpTransport>, LocalWallet>,
    contract_address: Felt,
    snos_config_hash: Felt,
) -> Result<TransactionResult> {
    let txn_config = TxnConfig::default();
    let invoker = Invoker::new(account, txn_config);

    let call = Call {
        to: contract_address,
        selector: selector!("set_program_info"),
        calldata: vec![
            BOOTLOADER_PROGRAM_HASH,
            snos_config_hash,
            SNOS_PROGRAM_HASH,
            LAYOUT_BRIDGE_PROGRAM_HASH,
        ],
    };
    let tx = invoker.invoke(call).await.unwrap();
    Ok(tx)
}

pub async fn set_fact_registry(
    account: SingleOwnerAccount<JsonRpcClient<HttpTransport>, LocalWallet>,
    contract_address: Felt,
    fact_registry_address: Felt,
) -> Result<TransactionResult> {
    let txn_config = TxnConfig::default();
    let invoker = Invoker::new(account, txn_config);

    let call = Call {
        to: contract_address,
        selector: selector!("set_facts_registry"),
        calldata: vec![fact_registry_address],
    };
    let tx = invoker.invoke(call).await.unwrap();
    Ok(tx)
}

#[derive(Debug, Clone)]
struct PreparedClass {
    label: String,
    class_hash: Felt,
    casm_class_hash: Felt,
    class: FlattenedSierraClass,
}

fn prepare_class(path: &Path, use_blake2s: bool) -> Result<PreparedClass> {
    let data = fs::read(path)?;

    let sierra: SierraClass = serde_json::from_slice(&data)?;
    let class_hash = sierra.class_hash()?;
    let flattened = sierra.clone().flatten()?;

    let casm_hash = casm_class_hash_from_bytes(&data, use_blake2s)?;

    let label = path
        .file_name()
        .and_then(|name| name.to_str())
        .ok_or_else(|| anyhow!("Unable to infer contract name from {}", path.display()))?
        .split('.')
        .next()
        .ok_or_else(|| anyhow!("Unable to infer contract name from {}", path.display()))?
        .to_string();

    Ok(PreparedClass {
        label,
        class_hash,
        casm_class_hash: casm_hash,
        class: flattened,
    })
}

fn casm_class_hash_from_bytes(data: &[u8], use_blake2s: bool) -> Result<Felt> {
    let sierra_class: ContractClass = serde_json::from_slice(data)?;
    let casm_class = CasmContractClass::from_contract_class(sierra_class, false, usize::MAX)?;

    let hash_version = if use_blake2s {
        HashVersion::V2
    } else {
        HashVersion::V1
    };
    let hash = casm_class.hash(&hash_version);

    Ok(Felt::from_bytes_be(&hash.0.to_bytes_be()))
}
#[derive(Clone, PartialEq, Eq, Hash, Default, Copy)]
pub struct ShortString {
    data: [u8; 31],
    len: u8,
}
impl ShortString {
    pub const fn from_ascii(s: &str) -> Self {
        let bytes = s.as_bytes();
        let len = bytes.len();

        assert!(len <= 31, "string is too long to be a Cairo short string");

        let mut data = [0u8; 31];
        let mut i = 0;
        while i < len {
            let b = bytes[i];
            assert!(b.is_ascii(), "invalid ASCII character in string");
            data[i] = b;
            i += 1;
        }

        Self {
            data,
            len: len as u8,
        }
    }
    /// Returns the bytes of the short string as a slice.
    pub const fn as_bytes(&self) -> &[u8] {
        // Use a manual slice since `&self.data[..self.len as usize]` is not const-stable
        unsafe { core::slice::from_raw_parts(self.data.as_ptr(), self.len as usize) }
    }
}

impl From<ShortString> for Felt {
    fn from(string: ShortString) -> Self {
        Self::from(&string)
    }
}

impl From<&ShortString> for Felt {
    fn from(string: &ShortString) -> Self {
        Felt::from_bytes_be_slice(string.as_bytes())
    }
}
fn compute_starknet_os_config_hash(
    chain_id: Felt,
    deprecated_fee_token: Felt,
    fee_token: Felt,
) -> Felt {
    // A constant representing the StarkNet OS config version.
    const STARKNET_OS_CONFIG_VERSION: ShortString = ShortString::from_ascii("StarknetOsConfig2");

    compute_hash_on_elements(&[
        STARKNET_OS_CONFIG_VERSION.into(),
        chain_id,
        deprecated_fee_token,
        fee_token,
    ])
}
